\section{Boosted Keyswitching}\label{sec:keyswitching}

Keyswitching is the dominant computation in FHE, especially for ciphertexts 
with high multiplicative budgets ($L$).
Thus, we use keyswitching to drive \name's design.


% FIXME(dsm): What't the point of this? Need table with operation types as a 
% function of L... and what are w/o CRB numbers???

Keyswitching consists of a large number of operations on residue polynomials and 
requires a large auxiliary operand called a  \emph{keyswitch hint} (KSH);
the KSH adds pressure on memory bandwidth and on-chip storage.

\figKScompare

Prior accelerators are optimized for the \emph{standard} keyswitching algorithm,
which is inefficient for deep computations.
By contrast, we target the keyswitching algorithm
proposed by Gentry et al.~\cite[Section 3.1]{gentry:crypto2012:homomorphic}.
In fact, there are multiple variants of this algorithm~\cite[Section 5.3.4]{halevi2020helib},
that we collectively refer to as \emph{boosted keyswitching}.
FHE libraries targeting deep computations
use boosted keyswitching~\cite{gentry:crypto2012:homomorphic,halevi2020helib,heaan,mouchet2020lattigo}.

The key innovation in boosted keyswitching is to expand the input polynomial to use wider coefficients.
This simplifies the KSH and its application.
Boosted keyswitching variants differ in how much they expand the input,
which introduces a tradeoff between performance and security.
We first analyze the most efficient variant (which expands the input the most),
then discuss the performance and security tradeoffs of different variants.

%(In fact, there are multiple variants of this algorithm~\cite[Section 5.3.4]{halevi2020helib};
%we adopt the variant that minimizes footprint).
%% nikola: I deleted "and compute operations", cuz it does more compute, but less compute per slot
%% ...but this argument only holds for CKKS and is subtle... the fact that it minimizes footprint is clear
%But as \autoref{sec:drawbacks} mentions, prior accelerators target standard keyswitching.
%%\footnote{F1 used an inefficient variant of boosted keyswitching, which only becomes beneficial for $L\geq20$. Instead, efficient boosted keyswitching with the proper hardware support outperforms standard keyswitching across all $L$.}


\autoref{fig:ksCompare} compares the memory footprint and compute cost (measured in scalar multiplications)
of standard and boosted keyswitching as a function of $L$ (the number of residue polynomials,
proportional to the bitwidth of $Q$).
Both algorithms have similar costs for small values of $L$, but costs
grow much more quickly with $L$ for standard keyswitching.

In particular, keyswitch hints are the size of
%four % dsm: ??? please check! (did you mean four ct polys? please use cts)
% nikola: yes, you are right; two ciphertexts
two
ciphertexts in the boosted algorithm.
This footprint reduction is the most important to \name.
% alex: It's a bit confusing that we use 26 MB ct here (L=64) here but 23 MB ct in background (L~=60)
%       I think both should use the same numbers.
% nikola: boosted KSH = 4*N*L*28 = 4 * 64*1024 * 60 * 28 = 52.5 MB
% standard KSH = 2*L^2*N*28 = 2 * 64^2 * 64*1024 * 28 /8/1024/1024 = 1,792 MB = 1.75 GB
For instance, at $N$=64K and $L$=60,
a keyswitch hint takes 52.5\,MB
instead of 1.7\,GB for the standard algorithm.
This enables holding KSHs on-chip and allows for high reuse.
%
\autoref{fig:ksCompare} also shows that boosted keyswitching reduces computational
costs across the range of multiplicative budget.

\autoref{listing:boostedKeyswitching} shows the implementation of boosted keyswitching.
Keyswitching takes a ciphertext polynomial and the keyswitching hint (KSH) as inputs,
and %combines them to 
produces two ciphertext polynomials as output.
% dsm: REVISION-TRIMMED
%(these outputs are used to produce
%the output ciphertext, as \autoref{listing:homomorphicMult} shows).
This variant of boosted keyswitching expands the input polynomial to use 2$\times$ wider coefficients;
this expansion reduces the KSH sizes and their application.
In RNS representation, this is accomplished through \verb!changeRNSBase()!,
which is used to both \emph{expand} the $L$-residue input into a $2L$-residue intermediate and later to \emph{shrink} the output
back to $L$ residues.
%dsm: If you need to say that this is Bajard et al, say it here in a parenthetical, but is this necessary??



    \begin{figure}\label{lst:boostedKeyswitching}
      \begin{center}
          \begin{lstlisting}[caption={Boosted keyswitching implementation.}, mathescape=true, style=custompython, label=listing:boostedKeyswitching]
def boostedKeySwitch(p[0:L]):
  pTmp[0:L] = INTT(p[0:L])
  pTmp[L:2L] = changeRNSBase(pTmp[0:L], [L:2L])
  p[L:2L] = NTT(pTmp[L:2L])
  for i = 0, 1:
    prod$\textsubscript{i}$[0:2L] = p[0:2L] * KSH$\textsubscript{i}$[0:2L]
    tmp$\textsubscript{i}$[0:2L] = INTT(prod$\textsubscript{i}$[L:2L], [0:L])
    mDTmp$\textsubscript{i}$[0:L] = changeRNSBase(tmp$\textsubscript{i}$[L:2L], [0:L])
    modDown$\textsubscript{i}$[0:L] = NTT(mDTmp$\textsubscript{i}$[0:L])
    ks$\textsubscript{i}$[0:L] = prod$\textsubscript{i}$[0:L] + modDown$\textsubscript{i}$[0:L]
  return (ks$\textsubscript{0}$[0:L], ks$\textsubscript{1}$[0:L])

def changeRNSBase(x[0:L], destModIdxList):
  for srcModIdx in [0:L]:
    for destModIdx in destModIdxList:
      C = constant[srcModIdx][destModIdx]
      result[destModIdx] += x[srcModIdx] * C 
  return result
          \end{lstlisting}
        \end{center}
      \end{figure}

\tblOpBalance

\autoref{tbl:opBalance} compares the operations used by boosted and standard keyswitching.
Whereas standard keyswitching has $L^2$ NTTs, boosted keyswitching uses only $O(L)$ NTTs:
a 10$\times$ reduction for $L$=60. To achieve this, boosted keyswitching incurs about 50\%
more multiplies and adds than standard keyswitching.
However, trading off fewer NTTs for more multiplies and adds is highly beneficial,
 % alex: We talk about vector ops everywhere else, so log N is fairer than N log N
because NTTs are much more complex, requiring $O(\log N)$ multiplies and adds.

Previous accelerators cannot perform boosted keyswitching efficiently because
they are designed to execute all multiplies and adds separately, resulting in an
overwhelming amount of register port pressure.
% FIXME(dsm): This number is meaningless here. Maybe later? But it's in the rebuttal and I don't think this is needed here--if anything, I'd add a more qualitative comparison to TPU/tensor cores later, which I think is more informative.
%: 15,360 reads and writes per cycle.
However, the bulk of these \mbox{operations} take place in \verb!changeRNSBase()!
(\autoref{tbl:opBalance}), and are structured as sequence of multiply and accumulate
operations (\autoref{listing:boostedKeyswitching})~\cite{bajard:2016:full}.
% nikola: please leave the citation to Bajard in there; otherwise, reviewer can
% rightfully complain that what we are implementing *does not change the RNS base*.
% Bajard is a chad and we would be toast without his insight.
\name exploits this by introducing a novel \verb!changeRNSBase()! functional
unit, \emph{CRB}, that buffers the intermediate sums and thereby reduces the
register file pressure \emph{by a factor of $L$} (i.e., up to 60$\times$).

Additionally, \autoref{listing:boostedKeyswitching} shows that most intermediate
variables are consumed immediately after being produced and can then be discarded.
\name exploits this by building \emph{configurable pipelines} of functional units,
further reducing register file reads and writes (\autoref{sec:keyswitchingPipeline}).

\subsection{Performance-Security Tradeoffs in Boosted Keyswitching}
\label{sec:boostedSecurity}

As \autoref{sec:deepChallenges} explained,
the security level of FHE depends on $N/logQ$:
the ratio between the number of polynomial coefficients and the width of each coefficient.
By expanding the input polynomial by a factor of two, the above boosted keyswitching algorithm increases the maximum $logQ$ by 2$\times$.
This would require either doubling $N$ or using half of the levels to achieve the same security level as standard keyswitching.

Since boosted keyswitching is much more efficient than standard algorithm, this is a worthwhile tradeoff.
Moreover, other boosted keyswitching variants offer finer control over this tradeoff.
Specifically, boosted keyswitching variants are parameterized by the number of so-called \emph{digits} $t$.
The variant described above is 1-digit keyswitching.
In $t$-digit keyswitching,
\emph{(1)} the input polynomial is expanded by a factor $t/(1+t)$;
\emph{(2)} keyswitch hint footprint is proportional to $1+t$; and
\emph{(3)} compute operations outside of \texttt{changeRNSBase} also increase, e.g., multipications grow by a factor $1+t$;
however, this is a minor effect, because \texttt{changeRNSBase} dominates the number of operations (\autoref{tbl:opBalance}),
and the total number of operations within \texttt{changeRNSBase} does not grow with the number of digits.

Concretely, using $t$=2, 3, or 4 digits increases the maximum $logQ$ by 1.5$\times$, 1.33$\times$, and 1.25$\times$, respectively.
Thus, higher-digit keyswitching variants reduce the $N$ required for a given level of security,
or increase the number of levels allowed between bootstrappings vs.\ 1-digit keyswitching.
The main drawback of these variants is that keyswitch hints grow quickly with the number of digits (by a factor $t+1$),
so whereas in 1-digit keyswitching each KSH is the size of 2 ciphertexts, with 2--4-digit keyswitching
each KSH takes 3--5 ciphertexts.
This makes these variant more memory-bound,
especially if the larger KSHs reduce the amount of on-chip reuse.

Achieving a given level of security efficiently requires carefully trading off
the keyswitching variant used and frequency of bootstrapping.
FHE programs also use multiple keyswitching variants over time:
higher-digit keyswitching may be necessary when $logQ$ is large,
but 1-digit keyswitching can be used when ciphertexts become narrower,
since a 2$\times$ expansion
does not affect the maximum $logQ$ of the computation.
Given these tradeoffs, FHE accelerators should support different keyswitching variants efficiently.
%
For example, to achieve 80-bit security with $N$=64K in our evaluation,
we use 2-digit keyswitching for multiplicative budgets $L>52$ and 1-digit keyswitching elsewhere;
we also show how to achieve higher security levels, e.g., 128 bits (\autoref{sec:moreSecurity}).



\begin{comment}
For a fixed amount of security budget and ciphertext polynomial degree,
boosted keyswitching allows for a maximum multiplicative bugdet that is 2$\times$
smaller compared
to standard keyswitching. This smaller multiplicative budget implies that for
deep programs boosted keyswitching requires about 2$\times$ as frequent
bootstrapping as standard keyswitching. As bootstrapping is often responsible
for a large part of computation time fo a deep FHE program, this overhead is
non-negligible.

However, the overheads of boosted keyswitching are compensated for by the fact
that boosted keyswitching allows us to keep multiple keyswitching hints on-chip (\autoref{fig:ksCompare}).
In contrast, standard keyswitching's keyswitch hints are up to 1.5$\,$GB in size,
far too large to fit on chip. Therefore, standard keyswitching is bottlenecked
by main memory bandwidth, even when HBM is used. For \name, being bottlenecked on
memory bandwidth leads to a 4$\times$ overhead, \emph{despite} \name's 1$\,$TB/s
memory badwidth.

Despite the performance advantage of boosted keyswitching, it is sometimes
beneficial to be able to support a multiplicative budget that is a few levels
larger than what boosted keyswitching allows. For example, depending on the
shape of the dataflow graph, a slightly higher multiplicative budget may allow
for us to bootstrap at narrower sections of the graph (i.e., bootstrap less ciphertexts)
than would be possible with a more restricted multiplicative budget.

Fortunately, boostead keyswitching offers a trade-off between keyswitch hint
footprint and maximum multiplicative budget, and \name supports all of these
variants. Specifically, the variants are parametrize by the number of so-called
\emph{digits} $t$ used when generating keyswitch hints. The variant described
in \autoref{lst:boosted} is 1-digit keyswitching.

For $t$-digit keyswitching the keyswitch hint footprint is proportional to $1+t$,
while the maximum multiplicative budget is proportional to $t/(1+t)$.

For our benchmarks, we use 2-digit keyswitching for multiplicative budgets $L>52$
in order to achieve the same multiplicative budgets as are used
in the CPU baselines and retain 80-bit security.

We use non-sparse keys and the most recent bootstrapping techniques~\cite{bossuat2021efficient} in order to
maximize our multiplicative budget without losing precision.
\end{comment}
